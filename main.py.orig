#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from datetime import datetime
import time, os
from dotenv import load_dotenv

from config import (USE_WEBSOCKET, USE_TESTNET, USE_LIVE, SCAN_INTERVAL_S, DAILY_TARGET_PCT, DAILY_LOSS_CAP,
                    PER_TRADE_RISK, SCAN_TOP_N, ALLOW_SHORT)
from utils import fetch_top_gainers, SESSION
from risk_frame import DayGuard, position_size_notional, compute_bracket
from adapters import SimAdapter, LiveAdapter
from signal_volume_breakout import volume_breakout_ok, volume_breakdown_ok
from panel import live_render
from ws_client import start_ws, stop_ws
import threading
from journal import log_trade
import sys, threading, termios, tty, select, math
from utils import load_exchange_info, EXCHANGE_INFO, update_time_offset

def state_iter():
    # hotkeys local imports (ensure available even if top-level imports failed)
    import sys, threading, termios, tty, select  # hotkeys

    load_dotenv(override=True)
    load_exchange_info() # <-- 新增：在啟動時載入精度規則

    day = DayGuard()
    adapter = LiveAdapter() if USE_LIVE else SimAdapter()

    # --- 修正：從 API 獲取真實餘額，而不是 .env ---
    if USE_LIVE:
        try:
            equity = adapter.balance_usdt()
            print(f"--- 成功獲取初始餘額: {equity:.2f} USDT ---")
        except Exception as e:
            print(f"--- 致命錯誤：無法獲取初始餘額: {e} ---")
            print("請檢查 API Key 權限或 .env 設定。程式即將退出。")
            sys.exit(1) # 退出程式
    else:
        equity = float(os.getenv("EQUITY_USDT", "10000")) # 模擬模式
        print(f"--- 模擬 (SIM) 模式啟動，初始權益: {equity:.2f} USDT ---")
        
    start_equity = equity
    last_scan = 0
    last_time_sync = time.time() # <-- 新增：記錄啟動時間
    prev_syms = []
    last_bal_ts = 0.0
    account = {"equity": equity, "balance": None, "testnet": USE_TESTNET}
    paused = {"scan": False}
    top10 = []
    events = []
    position_view = None
    vbo_cache = {} # <-- 新增：VBO 訊號快取
    # ---- anti-churn / re-entry guard ----
    COOLDOWN_SEC = 3             # 平倉後全域冷卻，避免下一輪又馬上下單
    REENTRY_BLOCK_SEC = 45       # 同一幣種平倉後禁止再次進場秒數
    cooldown = {"until": 0.0, "symbol_lock": {}}

    def log(msg, tag="SYS"):
        ts = datetime.now().strftime("%H:%M:%S")
        events.append((ts, f"{tag}: {msg}"))
    # --- 非阻塞鍵盤監聽（p: 暫停/恢復掃描, x: 立即平倉, !: 今日停機） ---
    def _keyloop():
        fd = sys.stdin.fileno()
        old = termios.tcgetattr(fd)
        try:
            tty.setcbreak(fd)
            while True:
                r,_,_ = select.select([sys.stdin],[],[],0.05)
                if r:
                    ch = sys.stdin.read(1)
                    if ch == "p":
                        paused["scan"] = not paused["scan"]
                        log(f"toggle pause -> {paused['scan']}", "KEY")
                    elif ch == "x":
                        if adapter.has_open():
                            try:
                                sym = adapter.open["symbol"]
                                entry = float(adapter.open["entry"])
                                side = adapter.open["side"]
                                nowp = adapter.best_price(sym)
                                pct = (nowp-entry)/entry if side=="LONG" else (entry-nowp)/entry
                                log_trade(sym, side, adapter.open.get("qty",0), entry, nowp, pct, "hotkey_x")
                                day.on_trade_close(pct)
                                adapter.open = None
                                log("force close position", "KEY")
                            except Exception as e:
                                log(f"close error: {e}", "KEY")
                        else:
                            log("no position to close", "KEY")
                    elif ch == "!":
                        day.state.halted = True
                        log("manual HALT for today", "KEY")
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old)

    threading.Thread(target=_keyloop, daemon=True).start()


    while True:
        t_now = time.time() # 取得一次當前時間
        day.rollover()
        # --- 新增：修復時間漂移 (Issue #2) ---
        if t_now - last_time_sync > 1800: # 每 30 分鐘 (1800 秒)
            try:
                new_offset = update_time_offset()
                log(f"Time offset re-synced: {new_offset} ms", "SYS")
                last_time_sync = t_now
            except Exception as e:
                log(f"Time offset sync failed: {e}", "ERROR")
                last_time_sync = t_now # 即使失敗也更新時間，避免 0.8s 後重試
        # --- 結束 ---

                # 1) 平倉監控
        if adapter.has_open():
            try:
                closed, pct, sym = adapter.poll_and_close_if_hit(day)
            except Exception as e:
                log(f"poll error: {e}")
                closed, pct, sym = False, None, None

            if closed:
                log(f"CLOSE {sym} pct={pct*100:.2f}% day={day.state.pnl_pct*100:.2f}%")
                # 冷卻避免馬上下單、並讓下一輪立即抓 balance
                cooldown["until"] = time.time() + COOLDOWN_SEC
                last_bal_ts = 0.0

                # --- 修正：平倉後立即更新權益 (equity) ---
                try:
                    if USE_LIVE:
                        equity = adapter.balance_usdt() # 更新用於下單的 equity
                        account["balance"] = equity    # 更新用於顯示的 balance
                        log(f"Balance updated: {equity:.2f}", "SYS")
                    else:
                        # 模擬模式：用 PnL 計算
                        equity = start_equity * (1.0 + day.state.pnl_pct)
                except Exception as e:
                    log(f"Balance update failed: {e}", "SYS")
                    equity = start_equity * (1.0 + day.state.pnl_pct) # 失敗時回退
                # --- 修正結束 ---
                
                position_view = None
        else:
            # 2) 無持倉：若未停機，掃描與找入場
            
            if not day.state.halted:
                # t = time.time() # <-- 這行可以刪了
                if not paused["scan"] and (t_now - last_scan > SCAN_INTERVAL_S):
                    try:
                        top10 = fetch_top_gainers(SCAN_TOP_N) # <-- 修正 1: 使用變數
                        last_scan = t_now
                        
                        # --- 核心優化：在這裡快取 VBO 訊號 ---
                        new_cache = {}
                        for s, pct, last, vol in top10:
                            # 修正 2: 呼叫 API (這才會發起請求)
                            new_cache[s] = volume_breakout_ok(s)
                        vbo_cache = new_cache # 原子化更新快取
                        # --- 優化結束 ---

                        log(f"top{SCAN_TOP_N} ok", "SCAN")
                        
                        if USE_WEBSOCKET:
                            syms = [t[0] for t in top10]
                            if syms != prev_syms:
                                start_ws(syms, USE_TESTNET)
                                prev_syms = syms
                    except Exception as e:
                        log(f"scan error: {e}", "SCAN")

                # 由上而下找第一個符合量價突破
                # 由上而下找第一個符合量價突破
                # 若還在冷卻，暫不找進場
                if time.time() < cooldown["until"]:
                    candidate = None
                else:
                    candidate = None
                for s, pct, last, vol in top10:
                    # 檢查同幣種 re-entry 鎖
                    lock_until = cooldown['symbol_lock'].get(s, 0)
                    if time.time() < lock_until:
                        continue
                    # --- 修正 4：從快取讀取 VBO 訊號 ---
                    if vbo_cache.get(s, False):
                        candidate = (s, last); break

                if candidate:
                    symbol, entry = candidate
                    side = "LONG"
                    notional = position_size_notional(equity)

                    # --- 修正：使用 ExchangeInfo 進行精確計算 (含即時刷新) ---
                    try:
                        # 1. 嘗試從 (可能過期的) 緩存獲取精度
                        prec = EXCHANGE_INFO[symbol]
                        qty_prec = prec['quantityPrecision']
                        price_prec = prec['pricePrecision']
                    except KeyError:
                        # 2. 緩存中沒有 (可能是新幣 AINUSDT)，觸發「即時刷新」
                        log(f"No exchange info for {symbol}. Attempting live refresh...", "SYS")
                        try:
                            # 呼叫 utils 函數，刷新全域 EXCHANGE_INFO
                            load_exchange_info()
                            
                            # 3. 再次嘗試從 (剛刷新的) 緩存中獲取
                            prec = EXCHANGE_INFO[symbol]
                            qty_prec = prec['quantityPrecision']
                            price_prec = prec['pricePrecision']
                            log(f"Successfully refreshed info for {symbol}", "SYS")

                        except KeyError:
                            # 4. 刷新後 "仍然" 沒有 (代表這是下市幣 TAGUSDT 或現貨幣)
                            #    啟動「猜測模式」作為最後手段
                            log(f"Refresh failed. {symbol} not in official list. Using fallback guess.", "ERR")
                            qty_prec = 0 # 數量取整數 (這個 OK)

                            # --- 修正：動態猜測價格精度 (更精確) ---
                            s_entry = f"{entry:.15f}" # 用 f 格式保留所有小數
                            if '.' in s_entry:
                                decimals = s_entry.split('.')[-1]
                                non_zero_idx = -1
                                for i, char in enumerate(decimals):
                                    if char != '0':
                                        non_zero_idx = i
                                        break
                                if non_zero_idx != -1:
                                    price_prec = non_zero_idx + 3 # 在第一個非零數字後再保留 3 位
                                else:
                                    price_prec = 4 # 預設
                            else:
                                price_prec = 0
                            
                            price_prec = min(price_prec, 8) # 最多 8 位
                            log(f"Guessed price_prec={price_prec} for {symbol}", "SYS")
                            # --- 修正結束 ---
                    
                    # 2. 計算並格式化 Qty (數量)
                    # 數量必須用 math.floor 進行「無條件捨去」到指定精度
                    qty_raw = notional / entry
                    qty_factor = 10**qty_prec
                    qty = math.floor(qty_raw * qty_factor) / qty_factor

                    if qty == 0.0:
                        log(f"Skipping {symbol}, calculated qty is zero (Notional={notional:.2f})", "SYS")
                        cooldown["until"] = time.time() + 1 # 避免
                        continue # 跳過此候選

                    # 3. 計算並格式化 Price (價格)
                    # 價格使用 round (四捨五入) 到指定精度
                    sl_raw, tp_raw = compute_bracket(entry, side)
                    
                    sl = round(sl_raw, price_prec)
                    tp = round(tp_raw, price_prec)
                    entry = round(entry, price_prec) # 也格式化 entry
                    
                    # --- 修正結束 ---

                    try:
                        # --- 修復：捕捉下單時的所有錯誤 (Issue #1) ---
                        adapter.place_bracket(symbol, side, qty, entry, sl, tp)
                        
                        # 只有在下單成功時，才執行以下動作
                        position_view = {"symbol":symbol, "side":side, "qty":qty, "entry":entry, "sl":sl, "tp":tp}
                        log(f"OPEN {symbol} qty={qty} entry={entry:.6f}", "ORDER")
                        cooldown["until"] = time.time() + COOLDOWN_SEC
                        cooldown["symbol_lock"][symbol] = time.time() + REENTRY_BLOCK_SEC

                    except Exception as e:
                        # 捕捉 TimeoutError, HTTPError, Insufficient Margin 等
                        log(f"ORDER FAILED for {symbol}: {e}", "ERROR")
                        # (發生錯誤時，我們只記錄日誌，然後繼續下一輪迴圈，程式不再崩潰)
                        pass

        # 依照可用資訊更新 Equity (顯示用)
        # (實際的 equity 變數已在啟動時和平倉後更新)
        account["equity"] = equity
        if USE_LIVE and account.get("balance") is None: # 處理第一次啟動時
            account["balance"] = equity

        # 3) 輸出給面板
        yield {
            "top10": top10,
            "day_state": day.state,
            "position": adapter.open if hasattr(adapter, "open") else (None if position_view is None else position_view),
            "events": events,
            "account": account,
        }

        time.sleep(0.8)

if __name__ == "__main__":
    try:
        live_render(state_iter())
    finally:
        try:
            stop_ws()
        except Exception:
            pass
